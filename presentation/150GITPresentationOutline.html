<html><head><title>150 GIT -- Presentation Outline</title><style type="text/css">ol{margin:0;padding:0}.c14{list-style-type:square;margin:0;padding:0}.c0{padding-left:0pt;direction:ltr;margin-left:108pt}.c7{max-width:468pt;background-color:#ffffff;padding:72pt 72pt 72pt 72pt}.c8{list-style-type:circle;margin:0;padding:0}.c13{list-style-type:disc;margin:0;padding:0}.c3{height:11pt;direction:ltr}.c4{direction:ltr;margin-left:36pt}.c5{direction:ltr}.c1{font-weight:bold}.c6{padding-left:0pt}.c9{text-decoration:underline}.c15{margin-left:108pt}.c2{font-style:italic}.c11{margin-left:72pt}.c10{margin-left:144pt}.c12{text-align:center}.title{padding-top:24pt;line-height:1.15;text-align:left;color:#000000;font-size:36pt;font-family:"Arial";font-weight:bold;padding-bottom:6pt}.subtitle{padding-top:18pt;line-height:1.15;text-align:left;color:#666666;font-style:italic;font-size:24pt;font-family:"Georgia";padding-bottom:4pt}li{color:#000000;font-size:11pt;font-family:"Arial"}p{color:#000000;font-size:11pt;margin:0;font-family:"Arial"}h1{padding-top:24pt;line-height:1.15;text-align:left;color:#000000;font-size:18pt;font-family:"Arial";font-weight:bold;padding-bottom:6pt}h2{padding-top:18pt;line-height:1.15;text-align:left;color:#000000;font-size:14pt;font-family:"Arial";font-weight:bold;padding-bottom:4pt}h3{padding-top:14pt;line-height:1.15;text-align:left;color:#666666;font-size:12pt;font-family:"Arial";font-weight:bold;padding-bottom:4pt}h4{padding-top:12pt;line-height:1.15;text-align:left;color:#666666;font-style:italic;font-size:11pt;font-family:"Arial";padding-bottom:2pt}h5{padding-top:11pt;line-height:1.15;text-align:left;color:#666666;font-size:10pt;font-family:"Arial";font-weight:bold;padding-bottom:2pt}h6{padding-top:10pt;line-height:1.15;text-align:left;color:#666666;font-style:italic;font-size:10pt;font-family:"Arial";padding-bottom:2pt}</style></head><body class="c7"><h2 class="c5"><a name="h.1gvveipfh9rh"></a><span>Nor&mdash;A Lightweight and Functional Version-Control System</span></h2><p class="c5"><span>Time : 25 mins.</span></p><p class="c3"><span></span></p><p class="c5"><span>~Thesis: Using parallel patches to represent differences between states in the repository allows simplified reasoning about merging and conflicts.</span></p><p class="c3"><span></span></p><p class="c5"><span class="c1 c2">Overview</span><span class="c2">&nbsp;- 2 minutes</span></p><ol class="c13" start="1"><li class="c4 c6"><span>merge -- difficult problem</span></li><li class="c4 c6"><span>git rebase + merge -- WAT</span></li><li class="c4 c6"><span>doesn&rsquo;t really work and nobody knows how it works - not a lot of literature</span></li><li class="c4 c6"><span>project goal: implement a vcs to understand the problem through real-world practice and not through existing products and documentation</span></li></ol><p class="c3"><span></span></p><p class="c5"><span class="c1 c2">Git is Cray</span><span class="c2">&nbsp;- 3 mins</span></p><ol class="c13" start="1"><li class="c4 c6"><span>talk about rebase + merge (if necessary)</span></li><li class="c4 c6"><span>show the rebase + merge example</span></li><li class="c4 c6"><span>a lot of confusion regarding how git actually works</span></li><li class="c4 c6"><span>segway: why we want to do nor</span></li></ol><p class="c3"><span></span></p><p class="c5"><span class="c1 c2">Introducing Nor</span><span class="c2">&nbsp;- 16 mins</span></p><p class="c4"><span>like git (state based, hashes, syntax)</span></p><p class="c4"><span class="c9">Patches</span><span>&nbsp;- 7 mins</span></p><ol class="c8" start="1"><li class="c5 c6 c11"><span>Diff -&gt; &nbsp;CE &gt;&gt; </span><span class="c1">show data type</span><span>&nbsp;</span></li><li class="c5 c6 c11"><span>show how they are canonical edits</span></li><li class="c5 c6 c11"><span>show the data type</span></li><li class="c5 c6 c11"><span>show how they are isomorphic to this new thing called parallel patches</span></li><li class="c5 c6 c11"><span>Define patch (</span><span class="c1">show data type</span><span>)</span></li><li class="c5 c6 c11"><span>Parallel patches</span></li></ol><ol class="c14" start="1"><li class="c0"><span>offsets which are defined in terms of the unmodified file (no dependency between patches)</span></li></ol><ol class="c8" start="7"><li class="c5 c6 c11"><span>Sequential Patches</span></li></ol><ol class="c14" start="1"><li class="c0"><span>permutations (parallelPatch) are all equal</span></li></ol><ol class="c13" start="1"><li class="c5 c6 c10"><span>very important, since when you apply a seq patch si, s1; s2 != s2; s1. BUT for parallel patch pi: (p1 || p2) == (p2 || p1)</span></li></ol><ol class="c14" start="2"><li class="c0"><span>only way to construct it is with parallel patches</span></li><li class="c0"><span>only way to eliminate a sequential patch is by applying ii</span></li></ol><p class="c3"><span class="c9"></span></p><p class="c4"><span class="c9">Conflicts &ldquo;maximal conflicting subsets&rdquo;</span><span>&nbsp;- 7 mins</span></p><ol class="c8" start="1"><li class="c5 c6 c11"><span>(Only changehunks conflict because the way we create delete empty files, they&rsquo;re always accompanied by a &ldquo;remove all lines&rdquo; which </span><span class="c2">is</span><span>&nbsp;detected as a conflict)</span></li><li class="c5 c6 c11"><span>What is a conflict? &gt;&gt; </span><span class="c1">show conflicts function</span></li><li class="c5 c6 c11"><span>Merging patches: parallel to combine, sequential to apply</span></li></ol><ol class="c14" start="1"><li class="c0"><span>This is better than sequential (diamond thing)</span></li></ol><ol class="c8" start="4"><li class="c5 c6 c11"><span>How conflicts work </span></li></ol><ol class="c14" start="1"><li class="c0"><span>Conflict graph </span></li><li class="c0"><span>demo it in slide!</span></li><li class="c0"><span>segway into</span></li></ol><ol class="c8" start="5"><li class="c5 c6 c11"><span>(Conflict -&gt; Patch)</span></li></ol><ol class="c14" start="1"><li class="c0"><span>&ldquo;viewable&rdquo; conflict patch, won&rsquo;t conflict w everything else</span></li><li class="c0"><span>given two changehunks in conflict</span></li><li class="c0"><span>compute affected lines</span></li><li class="c0"><span>create a new patch that shows affected lines of both lists</span></li><li class="c0"><span>parallel patch can now be applied to file</span></li><li class="c0"><span>this new changehunk doesn&rsquo;t conflict with anything else</span></li></ol><p class="c3 c15"><span></span></p><p class="c5 c12"><span>&nbsp; </span><span class="c1">Patch isomorphism</span></p><p class="c5 c12"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p><p class="c5 c12"><span class="c2">&nbsp; &nbsp; &nbsp;CE &lt;---&gt; CE x CE</span></p><p class="c5 c12"><span>&nbsp; ^ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^</span></p><p class="c5 c12"><span>&nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|</span></p><p class="c5 c12"><span>&nbsp; v &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v</span></p><p class="c5 c12"><span class="c2">&nbsp; &nbsp; &nbsp; PP &lt;---&gt; PP x PP</span></p><p class="c5 c12"><span>&nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|</span></p><p class="c5 c12"><span>&nbsp; v &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v</span></p><p class="c5 c12"><span class="c2">&nbsp; &nbsp; &nbsp; SP &lt;---&gt; SP x SP</span></p><p class="c3"><span class="c1"></span></p><p class="c3"><span class="c2"></span></p><p class="c5"><span class="c1 c2">Demo </span><span class="c2">- 4 mins</span></p><p class="c5"><span class="c9">Rebase </span><span>- 2 mins</span></p><p class="c5"><span>rebase is now easy with conflict graphs and patches.</span></p><p class="c5"><span class="c1">show diagram in slide (with 4&rsquo; 5&rsquo;)</span></p><h2 class="c5"><a name="h.u8d0e215bbpl"></a><span>use nor and rebase with these contents -</span></h2><p class="c5"><span>mkfile 1.test, fill with (words &ldquo;a b c d e f g h i&rdquo;)</span></p><p class="c5"><span>commit &nbsp;- get hash &lsquo;h1&rsquo;</span></p><p class="c5"><span>change file to (words &ldquo;a 0 2 d 4 6 8 h i&rdquo;)</span></p><p class="c5"><span>commit - get hash &lsquo;h2&rsquo;</span></p><p class="c5"><span>checkout &lsquo;h1&rsquo;</span></p><p class="c5"><span>change file to (words &ldquo;a b 1 3 5 f 7 h 9&rdquo;)</span></p><p class="c5"><span>commit - get hash &lsquo;h3&rsquo;</span></p><p class="c5"><span>rebase &lsquo;h2&rsquo; -- get conflict! resolve and then commit.</span></p><p class="c3"><span class="c2"></span></p><p class="c5"><span class="c1 c2">(Merge + Rebase) is hard</span><span class="c2">&nbsp;- 1 min</span></p><p class="c5"><span>git struggles with complexity too</span></p><p class="c5"><span>ancestor forest v. ancestor tree</span></p><p class="c3"><span></span></p><p class="c5"><span>================================================================</span></p><p class="c3"><span></span></p><p class="c5"><span>Choices made: </span></p><p class="c5"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;representation of repo (Core, Ephemera)</span></p><p class="c5"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;state-based vs change-based =&gt; patch ordering vs patch dependencies </span></p><p class="c5"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;only changehunks conflict (room for improvement)</span></p><p class="c3"><span></span></p><p class="c5"><span>Hard Things</span></p><p class="c5"><span>Struggle with patch types</span></p><p class="c5"><span>Not polymorphic</span></p><p class="c3"><span></span></p><p class="c5"><span>Merge + Rebase (in isolation, not too bad)</span></p><p class="c3"><span></span></p><p class="c5"><span>Things Learned</span></p><p class="c5"><span>Rebase &amp; use of lca</span></p><p class="c5"><span>git struggles with complexity too (rebase a merge)</span></p></body></html>